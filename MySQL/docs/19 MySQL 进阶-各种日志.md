# 1 redo 日志
## 1.1 什么是 redo 日志
事务具有“持久性”，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。<br />但是当修改数据库时，其实并不是直接写入到磁盘中的，而是先写入到内存中的 Buffer Pool 中，那么如果这时系统崩溃，导致内存中的数据丢失，而数据还没有写入到磁盘中，这种情况下该如何保证持久性呢？<br />一个简单的办法是，在事务提交完成之前，就将修改的数据写入磁盘，但是存在以下问题：

- 刷新一个完整的数据页太浪费了：如果我们的事务仅仅修改了某个页中的一个字节，而在 InnoDB 中需要以一个页为单位进行磁盘 IO，这样效率太低了。
- 随机 IO 刷起来比较慢：一个事务中可能需要修改多个页面，而这些页面在磁盘中可能并不相邻，这就导致需要进行很多次随机 IO。

所以 InnoDB 中使用了 redo 日志来解决这个问题，**每次提交事务时，不必将修改的所有页立刻写入磁盘中，只需要在 redo 日志文件里记录一下哪些数据被修改了**，比如：
```
将第 0 号表空间的 100 号页面的偏移量为 1000 处的值更新为 2
```
这样即使系统崩溃了，重启之后只需要根据 redo 日志的内容将数据恢复即可。<br />redo 日志具有以下优点：

- redo 日志占用的空间非常小。
- redo 日志是顺序写入磁盘的，因为我们添加 redo 日志时，只需要逐渐在 redo 日志文件结尾处追加即可。
## 1.2 redo 日志格式
针对场景定义了多种类型的 redo 日志，但是绝大部分类型的 redo 日志都有下边这种通用的结构：<br />![image.png](<../images/19 MySQL 进阶-各种日志/1.png>)

- type ：该条 redo 日志的类型。
- space ID ：表空间 ID。
- page number ：页号。
- data ：该条 redo 日志的具体内容。

redo 日志存储的是“在某个数据页上做了什么修改”，这种格式称之为物理日志，与之相对的是逻辑日志，比如 undo 日志和 binlog 日志，它们可以简单地理解为存储的是 SQL 语句。
## 1.3 redo 日志文件组
MySQL 的数据目录下有两个文件：ib_logfile0、ib_logfile1，这两个文件就是 redo 日志文件。<br />在 MySQL 配置文件中通过以下参数配置日志文件：

- innodb_log_group_home_dir：指定 redo 日志文件所在的目录，默认就是 data 目录。
- innodb_log_files_in_group：指定 redo 日志文件的个数，默认值为2，最大值为100。
- innodb_log_file_size：指定了每个 redo 日志文件的大小。

这些 redo 日志文件的工作方式是这样的，先向 ib_logfile0 中写入，写满了再向 ib_logfile1 中写入，以此类推，如果最后一个文件也写满了，那么再回到 ib_logfile0 中写入：<br />![image.png](<../images/19 MySQL 进阶-各种日志/2.png>)
## 1.4 redo 日志写入过程
我们知道为了解决磁盘 IO 过慢的问题而引入了 Buffer Pool，同样写入 redo 日志时也不能直接写到磁盘上，而是先写入到名为 redo log buffer 的内存块中，默认是 16 MB，可以在配置文件中配置其大小：
```bash
[mysqld]
innodb_log_buffer_size=32M
```
当满足一定条件时，redo log buffer 中的数据会刷新到磁盘中的 redo 日志文件中：

- log buffer 空间不足时：如果当前写入 redo log buffer 的 redo 日志量已经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。
- 事务提交时：为了保证持久性，事务提交时必须将 redo log buffer 的内容刷新到磁盘上。前面讲到，不能在每次事务提交时都将 Buffer Pool 中的数据刷新到磁盘中，但是 redo 日志更小，并且是顺序 IO，所以刷新 redo 日志到磁盘上的开销很小。
- 后台有一个线程，大约每秒都会刷新一次 redo log buffer 中的 redo 日志到磁盘。
- 正常关闭服务器时。
## 1.5 崩溃恢复
如果发生崩溃， 则 MySQL 重启时，会自动读取 redo 日志文件的内容，恢复数据。
# 2 undo 日志
## 2.1 什么是 undo 日志
前面讲到 **redo 日志是事务“持久性”的保证，而 undo 日志是事务“原子性”的保证**。<br />事务的原子性是指， 事务中的操作要么全部完成，要么什么也不做。<br />如何实现“什么也不做”呢？在事务执行的过程中，可能发生一些错误，或者手动执行了 ROLLBACK，就会导致“回滚”，撤销当前事务对数据库的更改，那么就好像“什么也不做”一样。要实现回滚，那么我们必须要把回滚时所需的东西都给记下来，比如：

- 当插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉。 
- 当删除了一条记录，至少要把这条记录中的内容都记下来，之后回滚时再把由这些内容组成的记录插入到表中。 
- 当修改了一条记录，至少要把修改这条记录前的旧值都记录下来，之后回滚时再把这条记录更新为旧值。

这些东西就是记录在 undo 日志中的。<br />为了实现事务的原子性， InnoDB 存储引擎在实际进行增、删、改一条记录时，都会先把对应的 undo 日志记录下来。<br />undo 日志没有单独的文件，它默认保存在系统表空间文件里，即数据目录下的 ibdata1 文件。
## 2.2 undo 日志格式
对于 INSERT、DELETE、UPDATE 这三种操作，它们对应的 undo 日志格式都不相同，以 INSERT 的 undo 日志为例：<br />![image.png](<../images/19 MySQL 进阶-各种日志/3.png>)<br />如上所示，它记录了 INSERT 操作的是哪个表，以及插入的记录的主键值，那么之后回滚时，就可以根据这个主键值去删除该记录。<br />这个格式可以简单地理解为是存储了一个 SQL 语句，所以 undo 日志为逻辑日志，同样为逻辑日志的还有 binlog 日志。
# 3 binlog 日志
## 3.1 什么是 binlog 日志
binlog 日志记录了所有对数据库的修改操作，包括 DDL 和 DML 操作，它与 redo 日志的区别在于：

- redo 日志是 InnoDB 引擎实现的，而 binlog 日志是在 MySQL 的 Server 层实现的，因此所有引擎都能使用。
- redo 日志是物理日志，存储的是“在某个数据页上做了什么修改”，而 binlog 是逻辑日志，可以简单地理解为存储的是 SQL 语句。

为什么有了 binlog 日志，InnoDB 还需要 redo 日志呢？简单来说，由于 MyISAM 引擎不支持事务，所以 binlog 日志不能用于崩溃恢复。<br />MySQL 中 binlog 日志默认是关闭的，需要在配置文件中添加以下配置：
```bash
[mysqld]
log-bin=mysql-bin-log # 开启 binlog，并设置 binlog 文件名为 mysql-bin-log，保存在数据目录下
server-id=1 # 集群环境中，每台机器都必须是不同的值
```
binlog 日志一般用于主从复制。
## 3.2 binlog 日志格式

- statment：记录每一条会对数据库产生变更操作的 SQL 语句（默认格式）。
- row：记录具体出现变更的数据（也会包含数据所在的分区以及所位于的数据页）。
- mixed：statment、row 的结合版，可复制的记录 SQL 语句，不可复制的记录具体数据。

在搭建主从架构时，一般采用 mixed 格式，因为默认的 statement 格式可能导致主从节点数据不一致的情况。比如当执行如下的语句时：
```sql
INSERT INTO `user` values(1, "Leo", 18, NOW());
```
同样的语句分别在主、从节点上执行时，NOW() 函数返回的时间肯定是不同的，那么就会导致主从节点数据不一致。<br />而 row 格式会导致主节点的 I/O 负载变高，传输时也会占用大量网络带宽，因此在主从复制中会使用 mixed 格式。<br />可以在配置文件中设置 binlog 日志格式：
```bash
[mysqld]
binlog_format=mixed
```
## 3.3 查看 binlog 日志内容
执行以下语句：
```sql
show binlog events in 'mysql-bin-log.000002'; -- 查看 mysql-bin-log.000002 文件的内容
```
结果如下：<br />![image.png](<../images/19 MySQL 进阶-各种日志/4.png>)
