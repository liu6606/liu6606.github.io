> [https://www.chanmufeng.com/posts/storage/MySQL/](https://www.chanmufeng.com/posts/storage/MySQL/)
> [https://juejin.cn/column/7140138832598401054](https://juejin.cn/column/7140138832598401054)
> [https://juejin.cn/book/6844733769996304392?scrollMenuIndex=2](https://juejin.cn/book/6844733769996304392?scrollMenuIndex=2)
> [https://docs.kilvn.com/mysql-learning-notes/](https://docs.kilvn.com/mysql-learning-notes/)

以下内容都是针对 InnoDB 存储引擎。
# 1 InnoDB 表如何存储
## 1.1 记录的存储格式
表中的一条记录在磁盘中的存放格式如下所示，也称作“行格式”：<br />![image.png](<../images/13 MySQL 进阶-索引原理/1.png>)<br />如上所示，“真实数据信息”为表中的一行记录的数据，next_record 记录下一条记录的位置，通过它，**记录之间会根据主键值由小到大的顺序连接成一个单向链表**，如下所示：<br />![image.png](<../images/13 MySQL 进阶-索引原理/2.png>)
## 1.2 数据页
我们知道数据是存储磁盘中的，当我们需要操作数据的时候，要将其读入到内存中，显然不能每操作一条数据，就读入一条数据，这样会产生大量的磁盘 I/O。<br />因此 InnoDB 将数据划分成若干个页，以页作为磁盘与内存间交互的最小单位。一个页中包含多条记录，当我们需要读入一条记录时，会将该条记录所在的页全部读取到内存中。默认情况下，一个页的大小为 16KB。<br />InnoDB 为了不同的目的而设计了许多种不同类型的页，我们将保存了存放记录的页称为数据页。一个数据页的结构如下所示：<br />![image.png](<../images/13 MySQL 进阶-索引原理/3.png>)

- Infimum、Supremum：两条伪记录，分别代表数据页中最小、最大的两条记录，它们不是我们自己插入的记录。
- User Records：保存了记录的空间。
- Free Space：空闲空间，当插入一条新记录时，就会从 Free Space 申请一条记录大小的空间，划分给 User Records。

另外，**页与页之间会通过双向链表连接在一起**。
## 1.3 页目录和槽
页目录指的就是上图中的 Page Directory 部分。<br />前面讲到，记录之间会根据主键值由小到大的顺序连接成一个单向链表，假设我们想根据主键值查找一条记录：
```sql
SELECT * FROM user WHERE id = 4;
```
最笨的办法就是定位到数据页之后，从 Infimum 伪记录开始沿链表向后找，但是这样的效率太慢了。<br />因此 InnoDB 采用了这种办法：

1. 将所有的记录划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该组内共有几条记录。  
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到 Page Directory 中，页面目录中的这些地址偏移量被称为“槽”。  

如下所示：<br />![image.png](<../images/13 MySQL 进阶-索引原理/4.png>)<br />这样的话就可以通过二分法快速的找到记录所在的组，然后在组内沿链表向后查找即可。
# 2 聚簇索引（主键索引）
要查找一条记录，首先需要找到记录所在的数据页，InnoDB 中使用 B+ 树来管理所有的数据页，通过这个 B+ 树就能够快速地找到记录所在的数据页，这个 B+ 树就叫作“聚簇索引”。也就是说一个 InnoDB 表的数据就是保存在一个聚簇索引中的，即所谓的“索引即数据，数据即索引”。<br />我们首先创建一个表：
```sql
CREATE TABLE `user_innodb` (
  `id` int,
  `name` varchar(255),
  `gender` tinyint(1),
  `phone` varchar(11),
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```
那么这个表的聚簇索引的结构如下：<br />![image.png](<../images/13 MySQL 进阶-索引原理/5.png>)

- 其中的叶子节点，就是存储了表中记录的数据页。
- 非叶子节点，称为目录项记录页。

将每个叶子节点中的最小主键和页号单独拿出来，放到上一层的非叶子节点中，作为一条目录项记录，同样，目录项记录也按照主键值由小到大的顺序连接成单向链表。这样的话，就可以通过二分查找快速地找到记录锁在的页。<br />另外，我们知道聚簇索引中的记录按照主键值由小到大的顺序连接成一个单向链表，因此每个表都必然是有一个主键的，当我们没有显式地指定一个列为主键时：

- 如果表中存在非空的唯一索引列，那么会选择它作为主键。
- 如果没有，则会自动添加一个 DB_ROW_ID 列作为主键，这个列我们看不到。
# 3 二级索引（辅助索引）
除了主键列外，我们也可以为其他列建立索引，称之为“二级索引”，跟聚簇索引一样，二级索引也使用 B+ 树来存储。<br />首先创建如下的表，为 name 列建立一个二级索引：
```sql
CREATE TABLE `user_innodb` (
  `id` int
  `name` varchar(255),
  `gender` tinyint(1),
  `phone` varchar(11),
  PRIMARY KEY (`id`),
  INDEX n(`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```
该二级索引的结构如下所示：<br />![image.png](<../images/13 MySQL 进阶-索引原理/6.png>)<br />它与主键索引的区别在于：

1. 叶子节点不再保存完整的表中记录，而是只保存被索引的那一列，即 name 列，以及主键值。
2. 记录之间不再按照主键大小排序，而是按照 name 列由小到大进行排序。
3. 非叶子节点保存了索引列值、主键值、页号。保存主键值的意义在于，不必找到叶子节点，就可以开始回表。
# 4 联合索引
## 4.1 概念
联合索引也是一种二级索引，区别在于联合索引为多个列建立一个索引。<br />首先创建如下的表，为 name 和 phone 列建立联合索引：
```sql
CREATE TABLE `user_innodb` (
  `id` int,
  `name` varchar(255),
  `gender` tinyint(1),
  `phone` varchar(11),
  INDEX(`name`, `phone`),
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```
该联合索引的结构如下所示：<br />![image.png](<../images/13 MySQL 进阶-索引原理/7.png>)

1. 叶子节点中保存了建立了联合索引的列，即 name 和 phone 列，以及主键值。
2. 叶子节点中的记录先按 name 由小到大排序，如果 name 相同，那么再按 phone 由小到大排序。
3. 非叶子节点中存储了建立了联合索引的那几列、主键值、以及页号。
## 4.2 索引覆盖
如果二级索引的叶子节点上保存了我们需要的所有列值，那么就不会产生回表，这就叫做索引覆盖。<br />比如我们只想查询 name、age 和主键列：
```sql
SELECT id, name, age FROM user WHERE name="Jack" AND age>18;
```
那么就可以建立 name 和 age 的联合索引。
## 4.3 最左前缀匹配原则
当我们创建一个联合索引，比如 (a, b, c)，那么在索引的 B+ 树中，保存了这三个索引列以及主键列的值，记录先按照列 a 由小到大排序，如果列 a 的值相等，再按照列 b 由小到大排序，如果列 b 的值相等，再按照列 c 由小到大排序。<br />我们知道索引使用 B+ 树来保存，而 B+ 树能加快查询的原因是使用了二分法，二分法就要求记录必须是有序的，因此查询时必须遵守最左前缀匹配原则：

- 如果以 (a)、(a, b)、(a, b, c) 作为查询条件（顺序任意），则都能够使用该索引。
- 否则，比如以 (a, c) 作为查询条件，只有列 a 能够用到索引，也就是说，在索引中只会按照列 a 的条件进行查找，然后在查询出的所有结果中，过滤掉不满足列 c 的条件的记录，这是因为索引中的记录并不是按照“先按列 a 由小到大的顺序、如果列 a 相等再按列 c 由小到大的顺序连接”。
```sql
CREATE TABLE `user` (
  `id` INT AUTO_INCREMENT,
  `a` INT,
  `b` INT,
	`c` INT,
	PRIMARY KEY(`id`),
	INDEX idx_a_b_c(`a`, `b`, `c`)
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

EXPLAIN SELECT a, c FROM `user` WHERE a=1 AND b=1 AND c=1;
```
执行·如上的 SQL 语句，可以看到 key_len 为 15（一个 INT 是 4 字节，允许 NULL 再加 1 字节），说明 a、b、c 这三列都使用了索引：<br />![image.png](<../images/13 MySQL 进阶-索引原理/8.png>)<br />但是如果不按照最左前缀匹配原则：
```sql
EXPLAIN SELECT a, c FROM `user` WHERE a=1 AND c=1;
```
此时 key_len 为 5，因为只有列 a 使用了索引：<br />![image.png](<../images/13 MySQL 进阶-索引原理/9.png>)
# 5 回表
在二级索引中，并没有保存完整的记录，只保存了索引列和主键列的值，那么当我们查询的列包含其他列时，就需要先在二级索引中取到记录的主键值，再去聚簇索引中查找到相应记录的其他列的值，这个过程就叫做回表。<br />回表存在的问题：第一次在二级索引中查找时还是很快的，但是在二级索引中查找出的记录的主键值是没有任何规律的，当再拿着这些主键值去聚簇索引中查找时，相应的记录所在页的页号也是毫无规律的，就会导致大量的随机 IO。<br />**因此我们应当尽力避免回表或减少回表的次数。**
# 6 页分裂
我们知道，聚簇索引的叶子节点中，记录按照主键由小到大的顺序连接成单向链表，页之间也按照主键的顺序连接成双向链表。<br />当我们使用自增主键时，插入操作就变得很简单，只需要定位到页之后，将记录直接插入页内的最后一条记录之后即可；如果页空间不足，就再申请一个页，将记录放到这个新创建的页中。<br />但是如果主键是乱序插入的，如下所示，有两个已经写满了数据的页：<br />![](<../images/13 MySQL 进阶-索引原理/10.png>)<br />现在我们要插入一条主键为 50 的记录，那么通过 B+ 树的查找，定位到第 1 页，而此时页已满，就会发生**页分裂**，将申请一个新的页，并将第 1 页的后半部分的记录拿出来，迁移到新的页中：<br />![](<../images/13 MySQL 进阶-索引原理/11.png>)<br />因为页分裂会导致页内一半的数据迁移到另一个页中，所以是比较耗时的。<br />**为了防止页分裂，主键应当使用自增主键，而不是使用 UUID 等无序的值。**
# 7 页合并
当页中被删除的的记录达到 MERGE_THRESHOLD（默认为页大小的 50%） 的时候，InnoDB 存储引擎会开始寻找两边的页，是否能够达到合并的条件，如果能就会产生页合并，以提高空间利用率：<br />![](<../images/13 MySQL 进阶-索引原理/12.png>)<br />如上所示，第二页被删除的数据达到了一半，因此与第三页合并：<br />![](<../images/13 MySQL 进阶-索引原理/13.png>)<br />但是跟页分裂一样，由于页合并会导致记录的迁移，所以可能会降低性能。<br />**为了防止页合并，可以采用逻辑删除的方式来删除记录**。方式是在表中添加一个 is_deleted 字段，当需要删除一条记录时，我们不使用 DELETE 语句，而是使用 UPDATE 语句来将 is_deleted 字段设置为 1，表示记录被删除：
```sql
UPDATE user SET is_deleted=1 WHERE name="Jack";
```
当我们查询数据的时候，只需要将 is_deleted=1 的记录过滤掉即可：
```sql
SELECT name, age FROM user WHERE is_deleted=0;
```
使用逻辑删除，还可便于恢复删除的数据，只需要将 is_deleted 字段设置为 0。
