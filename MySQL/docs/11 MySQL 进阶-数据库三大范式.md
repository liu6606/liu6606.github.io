> [https://cloud.tencent.com/developer/article/2232339](https://cloud.tencent.com/developer/article/2232339)

# 1 第一范式
每一个列都是不可再分的列。<br />例如下面这张表，由于 region 字段可以再细分为省份 province 和城市 city，所以此表将不满足第一范式：<br />![image.png](<../images/11 MySQL 进阶-数据库三大范式/1.png>)<br />将 region 字段拆分后，满足了第一范式：<br />![image.png](<../images/11 MySQL 进阶-数据库三大范式/2.png>)
# 2 第二范式
在满足第一范式后，消除非主属性对主属性的部分函数依赖。它是针对联合主键的，即非主键字段不能仅依赖于联合主键的部分字段。<br />先看看这张订单表，订单编号、商品 ID、用户 ID作为联合主键，每一个字段本身都不可再分，满足第一范式。<br />但用户名称字段仅依赖于用户 ID，所以此表并不满足第二范式：<br />![image.png](<../images/11 MySQL 进阶-数据库三大范式/3.png>)<br />在修改后，将变成两张表，分别为订单表和用户表：<br />![image.png](<../images/11 MySQL 进阶-数据库三大范式/4.png>)，![image.png](<../images/11 MySQL 进阶-数据库三大范式/5.png>)
# 3 第三范式
在第二范式的基础上，进一步消除非主属性对主属性的传递函数依赖。也就是说，每个非主键字段都只能依赖于主键字段，不能和另一个非主键字段有关联。<br />先来看这样一张订单表，订单 ID 是主键字段：<br />![image.png](<../images/11 MySQL 进阶-数据库三大范式/6.png>)<br />由于商品名称依赖于主键订单 ID，而同时又依赖于非主键字段商品 ID，所以不满足第三范式。<br />修改成以下两张表，将满足第三范式：<br />![image.png](<../images/11 MySQL 进阶-数据库三大范式/7.png>)![image.png](<../images/11 MySQL 进阶-数据库三大范式/8.png>)
# 4 反范式
随着范式的级别越高，设计出的结构会更加精细化，原本一张表的数据会被分摊到多张表中存储，表的数量随之越来越多。稍微复杂一些的查询语句在符合范式的数据库上都可能需要至少一次关联，也许更多，这不但代价昂贵，也可能使一些索引策略无效。<br />因此，也正是由于上述一些问题，在设计库表结构时，我们不一定要 100% 遵守范式准则。这种违反数据库范式的设计方法，就被称之为反范式设计。
